#these are variable declarations
# = means evaluate the value of this variable when called
# := means evaluate the value of this variable when declared
INPUT_FILES:=$(wildcard inputs/*)
INTERMEDIATE_STAGE_FILES=$(INPUT_FILES:inputs/%=intermediate_stage/%)
OUTPUT_FRAGMENTS=$(INTERMEDIATE_STAGE_FILES:intermediate_stage/%=outputs/%)

#rule 0: currently makes a single file consisting of all combined output fragments
#easy to run from command line - just type 'make'
#this has the file 'combined_outputs.txt' as a dependency
#the target is 'all', but no file named 'all' will be created since make knows this is a standard inbuilt phony target
#   Correction: The file named `all` is not created because there is no 
#   recipe to do so in this rule. Adding a .PHONY target will tell make
#   that the target *shouldn't* be created; it says nothing about whether
#   the target *is* created by the recipe.
all: combined_outputs.txt

#rule 1:
#recipe to make the file 'combined_outputs.txt'
#it's a target in this rule, unlike in the rule above where it is a dependency
#has two dependencies, both of which are variables defined at the start of this Makefile
#the two pattern rules below (rules 2 and 3) will be called as a result of these dependencies in rule 1
combined_outputs.txt: $(OUTPUT_FRAGMENTS) $(INTERMEDIATE_STAGE_FILES)
	cat $(OUTPUT_FRAGMENTS) >> $@
	shuf combined_outputs.txt -o combined_outputs.txt

#rule 2:
#this is a pattern rule (% signs on both sides)
#called because $(OUTPUT_FRAGMENTS) was listed as a dependency in rule 1 above
#notice that the patterns here are the same as the ones specified in the variable declaration for $(OUTPUT_FRAGMENTS) at the start of this Makefile
#the % expands to the same thing each time this rule is called, so this maps dependency filenames to target filenames, eg.
# intermediate_stage/file1.txt -> outputs/file1.txt
# intermediate_stage/file2.txt -> outputs/file2.txt
#this python script will be called for each of these files in turn
# $^ is shorthand for the first dependency
# $@ is shorthand for the target
#
# This would be better if it included the Python script as a dependency,
# so the target is rebuilt if the script is changed:
#   outputs/%: scripts/add_even_more_words.py intermediate_stage/%
#     python3 $^ > $@
outputs/%: intermediate_stage/%
	python3 scripts/add_even_more_words.py $^ > $@

#rule 3:
#this is another pattern rule, called because $(INTERMEDIATE_STAGE_FILES) is listed as a dependency in rule 1
#writing this rule as $(INPUT_FILES): $(INTERMEDIATE_STAGE FILES) doesn't work because $(INPUT_FILES) is a long list of filenames (uses the wildcard operator in the variable declaration)
#the first dependency always remains the same if $(INPUT_FILES) is given as a dependency
#using a pattern rule like this means the filenames are mapped to each other correctly, in sequence
#
# As above, this should include the Python script as a dependency.
intermediate_stage/%: inputs/%
	python3 scripts/add_words.py $^ > $@


#clean rule:
#this is another inbuilt phony rule make knows about by default, no file named 'clean' will be created
#used to remove files generated by this Makefile so that each runthrough starts fresh
#use 'make clean' in command line to run this
clean:
	rm $(INTERMEDIATE_STAGE_FILES)
	rm $(OUTPUT_FRAGMENTS)
	rm combined_outputs.txt
